// /src/reply.js

import {
  upsertSession, updateContact, saveMessage, loadRecentMessages,
  loadLatestSummary, logReply, getLastAuditCategory, getSession
} from "./db.js";

import { kbFind, kbInsertAnswer } from "./kb.js";

import {
  translateCached, translateWithStyle,
  toEnglishCanonical, detectLanguage
} from "./translator.js";

import {
  classifyCategory, detectAnyName, detectPhone,
  isCmdTeach, parseCmdTeach,
  isCmdTranslate, parseCmdTranslate,
  isCmdAnswerExpensive, extractGreeting
} from "./classifier.js";

import { runLLM } from "./llm.js";

import { buildSystemPrompt, buildMessages } from "./prompt.js";
import { ensureName, upsertFacts, getSessionProfile } from "./memory.js";
import { fetchRecentSummaries } from "./summaries.js";
import { maybeUpdateStyle } from "./style.js";
import { saveUserQuestion, findAnswerFromKB } from "./qna.js";

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ•
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

function buildAskName(userLang, rawText) {
  const hi = extractGreeting(rawText);
  const by = {
    ru: `${hi ? hi + ". " : ""}ĞŸĞ¾Ğ´ÑĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ĞºĞ°Ğº Ğ²Ğ°Ñ Ğ·Ğ¾Ğ²ÑƒÑ‚, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ Ğ·Ğ½Ğ°Ğ», ĞºĞ°Ğº Ğº Ğ²Ğ°Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒÑÑ?`,
    uk: `${hi ? hi + ". " : ""}ĞŸÑ–Ğ´ĞºĞ°Ğ¶Ñ–Ñ‚ÑŒ, Ğ±ÑƒĞ´ÑŒ Ğ»Ğ°ÑĞºĞ°, ÑĞº Ğ²Ğ°Ñ Ğ·Ğ²Ğ°Ñ‚Ğ¸, Ñ‰Ğ¾Ğ± Ñ Ğ·Ğ½Ğ°Ğ², ÑĞº Ğ´Ğ¾ Ğ²Ğ°Ñ Ğ·Ğ²ĞµÑ€Ñ‚Ğ°Ñ‚Ğ¸ÑÑ?`,
    pl: `${hi ? hi + ". " : ""}ProszÄ™ podpowiedzieÄ‡, jak ma Pan/Pani na imiÄ™, Å¼ebym wiedziaÅ‚, jak siÄ™ zwracaÄ‡?`,
    cz: `${hi ? hi + ". " : ""}ProsÃ­m, jak se jmenujete, aÅ¥ vÃ­m, jak vÃ¡s oslovovat?`,
    en: `${hi ? hi + ". " : ""}May I have your name so I know how to address you?`
  };
  return by[userLang] || by.en;
}

async function llmFallbackReply(sessionId, userTextEN, lang, promptExtras = {}) {
  // Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ â†’ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
  const recentRaw = await loadRecentMessages(sessionId, 18);
  const recent = (recentRaw || [])
    .map(m => ({ role: m.role, content: String(m.content ?? "") }))
    .filter(m => m.role && m.content);

  // Ğ¿Ğ°Ğ¼ÑÑ‚ÑŒ
  const summaries = await fetchRecentSummaries(sessionId, 3);
  const profile   = await getSessionProfile(sessionId);
  const system    = buildSystemPrompt({
    profile,
    summaries,
    facts: {
      user_name: profile?.user_name,
      country_interest: profile?.country_interest,
      intent_main: profile?.intent_main,
      candidates_planned: profile?.candidates_planned,
      stage: profile?.stage,
      psychotype: profile?.psychotype,
      ...promptExtras
    },
    locale: lang
  });

  const msgs = buildMessages({ system, userText: userTextEN });
  // Ğ¿Ğ¾Ğ´Ğ¼ĞµÑˆĞ¸Ğ²Ğ°ĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ (Ğ´Ğ¾ ÑĞ·ĞµÑ€ÑĞºĞ¾Ğ³Ğ¾)
  const safe = [msgs[0], ...recent, msgs[1]].map(m => ({ role: m.role, content: m.content }));
  const { text } = await runLLM(safe);
  return text;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ĞšĞĞœĞĞĞ”Ğ«
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

async function handleCmdTranslate(sessionId, rawText, userLang = "ru") {
  const { targetLangWord, text } = parseCmdTranslate(rawText);
  const targetLang = (targetLangWord || "en").toLowerCase();

  if (!text || text.length < 2) {
    const msg = "ĞÑƒĞ¶ĞµĞ½ Ñ‚ĞµĞºÑÑ‚ Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Â«ĞŸĞµÑ€ĞµĞ²ĞµĞ´Ğ¸Â».";
    const { canonical } = await toEnglishCanonical(msg);
    await saveMessage(
      sessionId, "assistant", canonical,
      { category: "translate", strategy: "cmd_translate_error" },
      "en", userLang, msg, "translate"
    );
    return msg;
  }

  const { targetLang: tgt, styled, styledRu } =
    await translateWithStyle({ sourceText: text, targetLang });

  const combined =
`ğŸ” ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´ (${tgt.toUpperCase()}):
${styled}

ğŸ’¬ Ğ”Ğ»Ñ Ñ‚ĞµĞ±Ñ (RU):
${styledRu}`;

  const { canonical } = await toEnglishCanonical(combined);
  await saveMessage(
    sessionId, "assistant", canonical,
    { category: "translate", strategy: "cmd_translate" },
    "en", userLang, combined, "translate"
  );

  return combined;
}

async function handleCmdTeach(sessionId, rawText, userLang = "ru") {
  const taught = parseCmdTeach(rawText);
  if (!taught) {
    const msg = "ĞÑƒĞ¶ĞµĞ½ Ñ‚ĞµĞºÑÑ‚ Ğ¿Ğ¾ÑĞ»Ğµ Â«ĞÑ‚Ğ²ĞµÑ‚Ğ¸Ğ» Ğ±Ñ‹Â».";
    const { canonical } = await toEnglishCanonical(msg);
    await saveMessage(
      sessionId, "assistant", canonical,
      { category: "teach", strategy: "cmd_teach_error" },
      "en", userLang, msg, "teach"
    );
    return msg;
  }
  const lastCat = (await getLastAuditCategory(sessionId)) || "general";
  const kbId = await kbInsertAnswer(lastCat, userLang || "ru", taught, true);

  const out = `âœ… Ğ’ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾.\n\n${taught}`;
  const { canonical } = await toEnglishCanonical(out);
  await saveMessage(
    sessionId, "assistant", canonical,
    { category: lastCat, strategy: "cmd_teach", kb_id: kbId },
    "en", userLang, out, lastCat
  );
  return out;
}

async function handleCmdAnswerExpensive(sessionId, userLang = "ru") {
  const kb = (await kbFind("expensive", userLang)) || (await kbFind("expensive", "ru"));
  let answer;
  if (kb?.answer) {
    answer = userLang !== "ru"
      ? (await translateCached(kb.answer, "ru", userLang)).text
      : kb.answer;
  } else {
    answer = await llmFallbackReply(
      sessionId,
      "Client says it's expensive. Give a brief WhatsApp-style response with value framing and a clear CTA.",
      userLang
    );
  }
  const { canonical } = await toEnglishCanonical(answer);
  await saveMessage(
    sessionId, "assistant", canonical,
    { category: "expensive", strategy: "cmd_answer_expensive" },
    "en", userLang, answer, "expensive"
  );
  await logReply(sessionId, "cmd", "expensive", kb?.id || null, null, "trigger: answer expensive");
  return answer;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ ĞĞ£Ğ¢Ğ•Ğ  (Ğ»ĞµĞ³ĞºĞ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑÑ‚ÑŒ)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

async function routeByCategory({ category, sessionId, userLang, userTextEN, userMsgId }) {
  // 1) Ğ¢Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ±Ğ°Ğ·Ğ° QnA (ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°)
  const kbExact = await findAnswerFromKB(userTextEN, 0.9);
  if (kbExact) {
    const { canonical } = await toEnglishCanonical(kbExact);
    await logReply(sessionId, "kb_exact", category, null, userMsgId, "qna exact");
    await saveMessage(
      sessionId, "assistant", canonical,
      { category, strategy: "kb_exact" },
      "en", userLang, kbExact, category
    );
    return kbExact;
  }

  // 2) ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹Ğ½Ğ°Ñ KB
  let kb = await kbFind(category, userLang);
  let answer = null;
  let strategy = "fallback_llm";
  let kbItemId = null;

  if (kb?.answer) {
    answer = kb.answer;
    strategy = "kb_hit";
    kbItemId = kb.id;
  } else {
    const kbRu = await kbFind(category, "ru");
    if (kbRu?.answer) {
      answer = (await translateCached(kbRu.answer, "ru", userLang)).text;
      strategy = "kb_translated";
      kbItemId = kbRu.id;
    }
  }

  // 3) LLM
  if (!answer) {
    answer = await llmFallbackReply(sessionId, userTextEN, userLang);
  }

  const { canonical: ansEN } = await toEnglishCanonical(answer);
  await logReply(sessionId, strategy, category, kbItemId, userMsgId, null);
  await saveMessage(
    sessionId, "assistant", ansEN,
    { category, strategy },
    "en", userLang, answer, category
  );
  return answer;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * SMART REPLY (Ğ³Ğ»Ğ°Ğ²Ğ½Ğ°Ñ Ñ‚Ğ¾Ñ‡ĞºĞ°)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

export async function smartReply(sessionKey, channel, userTextRaw, userLangHint = "ru", extra = {}) {
  const sessionId = await upsertSession(sessionKey, channel);

  // 0) ĞšĞ°Ğ½Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²Ñ…Ğ¾Ğ´Ğ°
  const { canonical: userTextEN, sourceLang: srcLang, original: origText } =
    await toEnglishCanonical(userTextRaw);
  const userLang = srcLang || userLangHint;

  // 1) ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
  if (isCmdTeach(userTextRaw)) {
    const msgId = await saveMessage(
      sessionId, "user", userTextEN,
      { kind: "cmd_detected", cmd: "teach" },
      "en", userLang, origText, null
    );
    const out = await handleCmdTeach(sessionId, userTextRaw, userLang);
    await logReply(sessionId, "cmd", "teach", null, msgId, "trigger: teach");
    return out;
  }

  if (isCmdTranslate(userTextRaw)) {
    const { text: t } = parseCmdTranslate(userTextRaw);
    if (t && t.length >= 2) {
      const msgId = await saveMessage(
        sessionId, "user", userTextEN,
        { kind: "cmd_detected", cmd: "translate" },
        "en", userLang, origText, null
      );
      const out = await handleCmdTranslate(sessionId, userTextRaw, userLang);
      await logReply(sessionId, "cmd", "translate", null, msgId, "trigger: translate");
      return out;
    }
  }

  if (isCmdAnswerExpensive(userTextRaw)) {
    const msgId = await saveMessage(
      sessionId, "user", userTextEN,
      { kind: "cmd_detected", cmd: "answer_expensive" },
      "en", userLang, origText, null
    );
    const out = await handleCmdAnswerExpensive(sessionId, userLang);
    await logReply(sessionId, "cmd", "expensive", null, msgId, "trigger: answer expensive");
    return out;
  }

  // 2) Ğ˜Ğ¼Ñ/ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚ + Ñ„Ğ°ĞºÑ‚Ñ‹
  // 2.1) Ğ¸Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ Ğ¸Ğ¼Ñ/Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½ Ğ¸Ğ· ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
  const nameInThisMsg = detectAnyName(userTextRaw);
  const phone = detectPhone(userTextRaw);
  if (nameInThisMsg || phone) await updateContact(sessionId, { name: nameInThisMsg, phone });

  // 2.2) Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ â€” Ğ¸Ğ¼Ñ Ğ¸Ğ· Telegram-Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
  await ensureName(sessionId, userTextRaw, extra?.tgMeta);

  // 2.3) Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğµ Ñ„Ğ°ĞºÑ‚Ñ‹ Ğ¸Ğ· Ñ‚ĞµĞºÑÑ‚Ğ°
  const facts = {};
  if (/Ñ‡ĞµÑ…/i.test(userTextRaw)) facts.country_interest = 'CZ';
  if (/Ğ¿Ğ¾Ğ»ÑŒÑˆ/i.test(userTextRaw)) facts.country_interest = 'PL';
  if (/Ğ»Ğ¸Ñ‚Ğ²/i.test(userTextRaw))  facts.country_interest = 'LT';
  if (/Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°/i.test(userTextRaw)) facts.intent_main = 'work';
  if (/Ğ±Ğ¸Ğ·Ğ½ĞµÑ/i.test(userTextRaw)) facts.intent_main = 'business';
  const num = userTextRaw.match(/\b(\d{1,3})\s*(ĞºĞ°Ğ½Ğ´Ğ¸Ğ´Ğ°Ñ‚|Ğ»ÑĞ´)/i)?.[1];
  if (num) facts.candidates_planned = Number(num);
  await upsertFacts(sessionId, facts);

  // 3) Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
  const userMsgId = await saveMessage(
    sessionId, "user", userTextEN,
    null, "en", userLang, origText, null
  );

  // 3.1) ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ² QnA-Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ (Ğ´Ğ»Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Â«Ñ Ğ±Ñ‹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ğ»Â»)
  await saveUserQuestion(sessionId, userTextEN);

  // 4) Ğ•ÑĞ»Ğ¸ Ğ¸Ğ¼ĞµĞ½Ğ¸ ĞµÑ‰Ñ‘ Ğ½ĞµÑ‚ â€” ÑĞ¿Ñ€Ğ¾ÑĞ¸Ğ¼ (Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ·)
  const session = await getSession(sessionId);
  const knownName = nameInThisMsg || session?.user_name?.trim();
  if (!knownName) {
    const ask = buildAskName(userLang, userTextRaw);
    const { canonical } = await toEnglishCanonical(ask);
    await saveMessage(
      sessionId, "assistant", canonical,
      { category: "ask_name", strategy: "precheck_name" },
      "en", userLang, ask, "ask_name"
    );
    return ask;
  }

  // 5) ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ğ¼ ÑÑ‚Ğ¸Ğ»ÑŒ Ğ¿Ğ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑĞ¼ (Ğ»Ñ‘Ğ³ĞºĞ°Ñ ÑĞ²Ñ€Ğ¸ÑÑ‚Ğ¸ĞºĞ°)
  await maybeUpdateStyle(sessionId);

  // 6) ĞšĞ»Ğ°ÑÑĞ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ â†’ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼
  const category = await classifyCategory(userTextRaw);

  switch (category) {
    case 'greeting':
    case 'smalltalk':
    case 'general':
    case 'visa':
    case 'work':
    case 'business':
    case 'docs':
    case 'price':
    case 'timeline':
    case 'process':
    case 'expensive':
    default:
      // Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ¿ÑƒÑ‚ÑŒ (KB exact â†’ KB category â†’ LLM)
      return await routeByCategory({ category, sessionId, userLang, userTextEN, userMsgId });
  }
}
